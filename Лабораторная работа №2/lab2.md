# Объектно-ориентированное программирование  

## Лабораторная работа №2  

[***Класс***](#класс)  
[***Свойства и методы***](#свойства-и-методы)  
[***Модификаторы доступа***](#модификаторы-доступа)  
[***Getter & Setter***](#getter--setter)  
[***Конструктор и Деструктор***](#конструктор-и-деструктор)    
[***Конструктор с параметрами***](#конструктор-с-параметрами)  
[***Список инициализации***](#список-инициализации-конструктора)  
[***QtCreator***](#qtcreator)  
[***Задание***](#задание)  
[***Вопросы***](#вопросы)

---  
## Теоретическая справка   

### Класс  

Это абстрактный тип данных, который сочетает в себе два функционала:
* Структура, в которой можно хранить различные типы данных.
* Объектно-ориентированное программирование.

```cpp
class /* Class Name */ {

};
```

### Свойства и методы
У класса есть свойства и методы.  

**`Свойства`** - все, что может хранить инфомацию(переменные, массивы и тд).   

```cpp
class Player {

    int level;
    float HP;
    std::string name;
    std::vector<std::string> skills;
};
```

**`Методы`** - это функции, в функционале которых можно использовать свойства. Методы объявляются в `.h` файле класса, а описываются в отдельном `.cpp` файле класса. 

```cpp
// -------------------------------------- //
// Player.h
// -------------------------------------- //
class Player {

    //Свойства
    int level;
    float HP;
    std::string name;
    std::vector<std::string> skills;

    //Методы
    void level_up(int lvl);
    std::string getName();
};

// -------------------------------------- //
//Player.cpp
// -------------------------------------- //

void Player::level_up(int lvl) {
    level += lvl;
}

std::string Player::getName() {
    return name;
}

```  

### Модификаторы доступа.  

У класса, в отличии от структуры, есть модификаторы доступа. Это называют **Инкапсуляцией**. 

**`public`** - дает общий доступ к содержимому, которое в нем указано. К свойствам и методам можно обратиться из любой части программы. По умолчанию все свойства и методы имеют модификатор **`public`**.

**`private`** - запрещает обращаться к свойствам вне класса. Как правило, переменные, массивы, а также прототипы функций создают с этим модификатором доступа. Изменять переменные и прочее можно только из методов класса.   

> P.S Есть еще и третий модификатор доступа - Protected. О нем поговорим позже в лабе с наследованием.


### Getter & Setter

Модификаторы доступа приводят нас к понятию `getter` и `setter`. Так называют методы класса, которые позволяют получить или задать значения свойствам класса, которые имеют модификатор доступа `private`.

`getter` должен иметь тип `void` и принимать в качестве параметра значение, которое мы хотим установить.

`setter` же наоборот должен иметь тип свойства, которое мы будем возвращать.

Изменим код выше и добавим модификаторы доступа, а также геттеры и сеттеры.

```cpp
// -------------------------------------- //
// Player.h
// -------------------------------------- //
class Player {

private:
    //Свойства
    int level;
    float HP;
    std::string name;
    std::vector<std::string> skills;

public:
    //Методы
    void level_up(int lvl);
    std::string getName(); // <-- В предыдущем примере уже был геттер

    //getter & setter
    void setSkills(std::string skillName);
    float getHP();
};

// -------------------------------------- //
//Player.cpp
// -------------------------------------- //

void Player::level_up(int lvl) {
    vevel += lvl;
}

std::string Player::getName() {
    return name;
}

//getter & setter
void Player::setSkills(std::string skillName) {
    skills.push_back(skillName);
}

float Player::getHP() {
    return HP;
}

```

### Конструктор и деструктор.  

**`Конструктор`** — это метод, который вызывается во время создания класса. Конструктор должен называться также, как и сам класс. 

**`Деструктор`** — тоже метод, только вызывается после удаления класса. Деструктор должен называться аналогично, как и констурктор, но с тильдой (~).

```cpp
// -------------------------------------- //
// Player.h
// -------------------------------------- //
class Player {

public:
    Player();  // <-- Конструктор
    ~Player(); // <-- Деструктор

};

// -------------------------------------- //
//Player.cpp
// -------------------------------------- //

Player::Player() {
    //Code
    //Example:
    std::cout << "Moshi moshi, Constructor-kun desu" << std::endl;
}

Pleyer::~Player(){
    //Code
    //Example:
    std::cout << "Mr. Class I Don't feel so good..." << std::endl;
}
```

### Конструктор с параметрами.

Конструктор может быть с параметрами. Тогда при инициализации объекта класса мы сможем инициализировать какие либо свойства. К примеру, если у нас есть класс игрока, то при его появлении у него должны быть HP, уровень и ник.
```cpp
// -------------------------------------- //
// Player.h
// -------------------------------------- //
class Player {

private:
    int level;
    float HP;
    std::string name;

public:
    Player();  // <-- Конструктор
    Player(int lvl, float hp, std::string name); // <-- Конструктор с параметрами
};

// -------------------------------------- //
//Player.cpp
// -------------------------------------- //

Player::Player() {
    std::cout << "Moshi moshi, Constructor-kun desu" << std::endl;
}

Player::Player(int lvl, float hp, std::string name) {
    level = lvl;
    HP = hp;
    name = name;
}

// -------------------------------------- //
//main.cpp
// -------------------------------------- //

Player player(1, 100, "NoobMaster69"); 

//По-скольку мы перегрузили конструктор, то можно не передавать параметры 
//Вариант 
Player player();
//Также будет работать.
```

### Список инициализации конструктора.  

Списки инициализации представляют собой перечисления инициализаторов для каждой из переменных и констант через двоеточие после списка параметров конструктора. 

```cpp
//Конструктор со списком инициализации
Player::Player(): level{ 1 }, HP{ 100 }, name{ "Kirito" } {}

//Конструктор с параметрами
Player::Player(int lvl, float hp, std::string name) {
    level = lvl;
    HP = hp;
    name = name;
}

////Конструктор с параметрами и со списком инициализации.
Player::Player(int lvl, float hp, std::string name): level{lvl}, HP{hp}, name{name} {

}

//P.S Списки инициализации уже встречались раньше в векторах.
std::vector<int> numbers = {3, 1, 4, 1}; //<--тут тоже список инициализации вектора

```

### QtCreator  

#### Получить путь до файла.

```cpp
QString filePath = QFileDialog::getOpenFileName(0, "Open File", "", "*.csv"); 
// "*.csv" - будут отобраться только файлы с таким расширением.
// "*.*" - отображение всех файлов
```
#### Получить имя файла без пути.
```cpp
QFile file(filePath);                                    //input: ./Argus/SAO/UI.ai
QString fileName = file.fileName().section("/", -1, -1); //output: UI.ai
```
#### Получить расширение файла.
```cpp
QFileInfo file(filePath);               //input: data.json
QString fileExtension = file.suffix();  //output: .json 
```

---


P.S Теория будет пополняться.

---
## **Задание**  
В данной лабораторной работе вам необходимо разработать графический интерфейс и перевести из функционального стиля в ООП стиль код предыдущей лабы. 

Графическое окно должно иметь:
* `TextBrowser` поле для отображения информации.
* `QButton` кнопку поиска и открытия файла.
* `line edit` поле ввода для поиска.  

P.S Что-то можно поменять или переписать

---  

#### **Этапы выполнения**  

1. Создать графический интерфейс.

2. Написать класс для хранения информации о фигурах.

3. Прикрепить интерфейс к коду.

4. Добавить сортировку и вывод данных.  

5. Добавить вывод отсортированных данных в файл.

---

## Вопросы

1. Что такое Класс?
2. Что такое методы и свойства?
3. Что такое конструктор и деструктор?
4. Что такое модификаторы доступа?
5. Что такое конструктор с параметрами?
6. Что такое список инициализации?

TBC...

