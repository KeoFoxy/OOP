# Объектно-ориентированное программирование  

## Лабораторная работа №2  
---  
### Теоретическая справка   

#### Класс  

Это абстрактный тип данных, который сочетает в себе два функционала:
* Структура, в которой можно хранить различные типы данных.
* Объектно-ориентированное программирование.

```cpp
class /* Class Name */ {

};
```

У класса есть свойства и методы.  

**`Свойства`** - все, что может хранить инфомацию(переменные, массивы и тд).   

```cpp
class Player {

    int level;
    float HP;
    std::string name;
    std::vector<std::string> skills;

};
```

**`Методы`** - это функции, в функционале которых можно использовать свойства. Методы объявляются в `.h` файле класса, а описываются в отдельном `.cpp` файле класса. 

```cpp
// -------------------------------------- //
// Player.h
// -------------------------------------- //
class Player {

    //Свойства
    int level;
    float HP;
    std::string name;
    std::vector<std::string> skills;

    //Методы
    void level_up(int lvl);
    std::string getName();
};

// -------------------------------------- //
//Player.cpp
// -------------------------------------- //

void Player::level_up(int lvl) {
    level += lvl;
}

std::string Player::getName() {
    return name;
}

```  

##### Модификаторы доступа.  

У класса, в отличии от структуры, есть модификаторы доступа. Это называют **Инкапсуляцией**. 

**`Public`** - дает общий доступ к содержимому, которое в нем указано. К свойствам и методам можно обратиться из любой части программы.

**`Private`** - запрещает обращаться к свойствам вне класса. Как правило, переменные, массивы, а также прототипы функций создают с этим модификатором доступа. Изменять переменные и прочее можно только из методов класса.   

> P.S Есть еще и третий модификатор доступа - Protected. О нем поговорим позже в лабе с наследованием.

Это приводит нас к понятию `getter` и `setter`. Так называют методы класса, которые позволяют получить или задать значение свойствам класса, которые имеют модификатор доступа `private`.

`getter` должен иметь тип `void` и принимать в качестве параметра значение, которое мы хотим установить.

`setter` же наоборот должен иметь тип свойства, которое мы будет возвращать.

Изменим код выше и добавим модификаторы доступа и геттеры и сеттеры.

```cpp
// -------------------------------------- //
// Player.h
// -------------------------------------- //
class Player {

private:
    //Свойства
    int level;
    float HP;
    std::string name;
    std::vector<std::string> skills;

public:
    //Методы
    void level_up(int lvl);
    std::string getName(); // <-- В предыдущем примере уже был геттер

    //getter & setter
    float getHP();
    void setSkills(std::string skillName);
};

// -------------------------------------- //
//Player.cpp
// -------------------------------------- //

void Player::level_up(int lvl) {
    vevel += lvl;
}

std::string Player::getName() {
    return name;
}

//getter & setter
void Player::setSkills(std::string skillName) {
    skills.push_back(skillName);
}

float Player::getHP() {
    return HP;
}

```

##### Конструктор и деструктор.  

**`Конструктор`** — это метод, который вызывается во время создания класса. Конструктор должен называться также, как и сам класс.

**`Деструктор`** - тоже метод, только уже вызывается после удаления класса. Деструктор должен называться аналогично, как и констурктор, но с тильдой (~).

```cpp
// -------------------------------------- //
// Player.h
// -------------------------------------- //
class Player {

public:
    Player();  // <-- Констурктор
    ~Player(); // <-- Деструктор

};

// -------------------------------------- //
//Player.cpp
// -------------------------------------- //

Player::Player() {
    //Code
    //Example:
    std::cout << "Hello" << std::endl;
}

Pleyer::~Player(){
    //Code
    //Example:
    std::cout << "Bye" << std::endl;
}
```

##### Сортировка  
Методов сортировки существует множество, рассмотрим функцию сортировки из STL библиотеки. 
Пример сортировки:  
```cpp
#include <algorithm>

std::vector<int> numbers = {3, 1, 4, 1, 5, 9, 2, 6};
std::sort(numbers.begin(), numbers.end(), [](int a, int b){ 
    return a < b; 
});
```

P.S Кто напишет лучший собственный метод сортировки с лучшим O(n), тот получит +балл на экзамене. :)  

---

##### Чтение файлов  
Для чтения файлов используется класс ifstream из fstream. 
```cpp
#include <fstream>

int main() {
    std::ifstream file("example.txt");

    if (file.is_open()) {
        std::string line;

        while (!file.eof()) {
            std::getline(file, line)
            std::cout << line << std::endl;
        }

        file.close();   
    } else {
        std::cout << "Failed to open file" << std::endl;
    }
    return 0;
}

```

P.S Теория будет пополняться.

---
## **Задание**  
В данном курсе на лабораторных работах мы будем разрабатывать программу для работы и взаимодействия с геометрическими объектами.  

В первой лабораторной работе необходимо написать программу, которая будет считывать из CSV файла (файл будет дан) данные, сортировать их и выводить в консоль. 

P.S Что-то можно поменять или переписать

---  
#### **Варианты**   

CSV файл с данными у всех один. Необходимо считать заданные данные.
Пример, как выглядит CSV файл внутри.
```csv
id; figure-name; angles; color(enum)
```

1. Вариант  
Считать фигуры: **трапеции, пятиугольники, шестиугольники.** 
Если такой фигуры нету в файле, то выдать сообщение об ошибке ??**и добавить ее самостоятельно.**??  

***Отсортировать фигуры по количеству углов. Вывести в консоль все трапеции синего цвета.***

2. Вариант:   
Считать фигуры: **треугольники, пятиугольники, круги** ??   
Если такой фигуры нету в файле, то выдать сообщение об ошибке ??**и добавить ее самостоятельно.**  

***Отсортировать фигуры по количеству углов. Вывести в консоль все круги розового цвета***   

3. Вариант:  
Считать фигуры: **прямоугольники, круги, трапеции**  
Если такой фигуры нету в файле, то выдать сообщение об ошибке ??**и добавить ее самостоятельно.** 

***Отсортировать фигуры по количеству углов. Вывести в консоль все четырехугольники зеленого цвета***   

---

#### **Этапы выполнения**  

1. Разобрать пример реализации функции split, проверить работоспособность с помощью отладчика. Найти ошибки в реализации, пофиксить.
```cpp
std::vector<std::string> split(const std::string& str, char delim)
{
    std::vector<std::string> tokens;

    if (!str.empty()){
        size_t start = 0, end;
        do {
            tokens.push_back(str.substr(start, (end - start)));
            end = str.find(delim, start);
            start = end + 1;
        } while (end != std::string::npos);
    }

    return tokens;
}
```  
2. Используя исправленную функцию split и функции потокового чтения из файла, сделать чтение записей.
3. Добавить сортировку и вывод данных.  

4. Добавить вывод отсортированных данных в файл.

---

## Вопросы

1. Что такое **CSV**?
2. Что такое **ENUM**?
3. std::sort (Что сюда придумать я хз)
4. Что такое функциональное программирование и какое отличие от ООП?
5. Что такое лямбда функция?
6. Какие атрибуты функционального программирования нам известны?
